<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">
  <title>五子棋游戏</title>
  <meta name="keywords" content="五子棋游戏">
  <meta name="description" content="五子棋游戏">
  <style>
    body {
      height: 100%;
      margin: 0;
    }

    .flex {
      display: flex;
      /* align-items: center; */
      justify-content: center;
      height: 100vh;
    }

    #board {
      background-image: url('https://assets.19x19.com/img/skin/board/b1.png');
      background-size: 100%;
      width: 480px;
      height: 480px;
      position: relative;
    }

    #mark,
    #step {
      position: absolute;
      top: 0;
      left: 0;
    }

    canvas {
      display: block;
    }

    .dialog {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, .45);
      display: none;
    }

    .dialog.open {
      display: block;
    }

    .dialog .alert {
      background-color: rgba(255, 255, 255, .9);
      border-radius: 5px;
      box-shadow: 1px 2px 8px rgba(0, 0, 0, .5);
      width: 250px;
      height: 160px;
      left: 50%;
      top: 50%;
      position: absolute;
      text-align: center;
      margin: -80px 0 0 -125px;
    }

    button {
      border: none;
      background-color: rgb(68, 183, 58);
      color: #fff;
      padding: 10px 20px;
      border-radius: 4px;
      outline: none;
      transition: all 300ms;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0, 0, 0, .5);
    }

    button:hover {
      background-color: rgba(68, 183, 58, .9);
    }

    button:active {
      box-shadow: none;
    }

    .dialog p {
      margin: 0 0 16px 0;
    }

    .desc {
      max-width: 20vw;
      min-width: 258px;
      font-size: 14px;
      margin-left: 30px;
      display: flex;
      flex-direction: column;
    }

    .desc p {
      font-weight: bold;
    }

    .desc ul {
      padding-left: 14px;
    }

    .rule {
      flex: 1;
    }

    
    /* 当屏幕的宽高比小于 4/3 时应用样式 */
    @media (max-aspect-ratio: 1) {
      .flex {
        flex-direction: column;
      }

      .desc {
        flex-direction: row;
        max-width: none;
        min-width: none;
        margin: 50px 0 0 0;
      }

      .desc button {
        flex: 1;
      }

      .rule {
        display: none;
      }
    }
  </style>
</head>

<body>
  <div class="flex">
    <div id="board">
      <canvas id="game" width="480" height="480"></canvas>
      <canvas id="mark" width="480" height="480"></canvas>
      <canvas id="step" width="480" height="480"></canvas>
    </div>
    <div class="desc">
      <div class="rule">
        <p>五子棋的基本下法包括：</p>
        <ul>
          <li>双方分别使用黑白两色的棋子。</li>
          <li>空棋盘开局，黑色棋子先下，白色棋子后下。</li>
          <li>交替下子，每次只能下一子。</li>
          <li>棋子下在棋盘的空白点上，一旦下定后不得向其他点移动。</li>
          <li>不得从棋盘上拿掉或拿起另落别处。</li>
          <li>黑方的第一枚棋子可下在棋盘任意交叉点上。</li>
          <li>轮流下子是双方的权利，但允许任何一方放弃下子权。</li>
        </ul>
        <p>五子棋的比赛规则包括：</p>
        <ul>
          <li>黑先、白后，从天元点开始相互顺序落子于15×15的专用棋盘的交叉点上。</li>
          <li>最先在棋盘横向、竖向、斜向形成连续的相同色五个棋子的一方为胜。</li>
          <li>黑棋禁手判负，白棋无禁手。黑棋禁手包括“三、三”，“四、四”，“长连”。黑方只能“四、三”取胜。</li>
          <li>如分不出胜负，则定为平局（和棋）。</li>
          <li>以局中拨子、中途退场均判为负。</li>
          <li>五连与禁手同时形成，先五为胜。</li>
          <li>黑方禁手形成时，白方应立即指出。若立方发现后仍继续应子走棋，则不能判黑方禁手负。</li>
          <li>白方走出长连也算胜。白方亦可自由地走“三、三”、“四、四”或“四、三”等。</li>
        </ul>
      </div>
      <button style="margin: 10px;background-color: #fff; color: #000;" onclick="showStep()">手数(123)</button>
      <button style="margin: 10px;" onclick="restart()">重新开始</button>
    </div>
  </div>
  <div id="dialog" class="dialog" onclick="this.className='dialog'">
    <div class="alert">
      <h4 id="title">恭喜!</h4>
      <p id="winner"></p>
      <button>知道了</button>
    </div>
  </div>
  <img id="black" style="display: none;" src="https://assets.19x19.com/img/skin/stone/shell_stb3.png" />
  <img id="white" style="display: none;" src="https://assets.19x19.com/img/skin/stone/shell_stw1.png" />
  <script>
    const canvas = document.getElementById('game');
    const mark = document.getElementById('mark');
    const step = document.getElementById('step');
    const boardDom = document.getElementById('board');
    const pieceImages = {
      black: document.getElementById('black'),
      white: document.getElementById('white')
    }
    const audio = new Audio('https://assets.19x19.com/voice/play.wav'); // 落子声音
    const winAudio = new Audio('https://assets.19x19.com/voice/win.wav'); // 胜利声音
    const ctx = canvas.getContext('2d');
    const mctx = mark.getContext('2d');
    const nctx = step.getContext('2d');
    const max = Math.min(window.innerWidth, window.innerHeight);
    const cellSize = max / 16; // 每个格子的大小
    const boardSize = 15; // 棋盘的大小，15x15
    let currentPlayer = { x: 0, y: 0, step: 0, color: 'black' }; // 当前玩家
    let currentStep = 1; // 当前手数
    let gameOver; // 游戏是否结束
    let gameBoard; // 游戏棋盘
    let lastHoverPoint; // 鼠标上一次位置
    let stepShow = false; // 是否开启步数显示

    boardDom.style = `width: ${max}px; height: ${max}px`;
    canvas.width = max;
    canvas.height = max;
    mark.width = max;
    mark.height = max;
    step.width = max;
    step.height = max;

    // 绘制棋盘
    function drawBoard() {
      ctx.lineCap = 'square';
      ctx.strokeStyle = 'black';
      for (let i = 0; i < boardSize; i++) {
        ctx.lineWidth = i === 0 || i === boardSize - 1 ? 1 : 0.5;
        ctx.beginPath();
        ctx.moveTo(cellSize + i * cellSize, cellSize);
        ctx.lineTo(cellSize + i * cellSize, cellSize * boardSize);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(cellSize, cellSize + i * cellSize);
        ctx.lineTo(cellSize * boardSize, cellSize + i * cellSize);
        ctx.stroke();

        // 绘制九个标记点
        if (i === 4 || i === (boardSize + 1) / 2 || i === boardSize - 3) {
          ctx.beginPath();
          ctx.arc(cellSize * i, cellSize * i, 3, 0, 2 * Math.PI);
          if (i === 4) {
            ctx.arc(cellSize * ((boardSize + 1) / 2), cellSize * i, 3, 0, 2 * Math.PI);
            ctx.arc(cellSize * (boardSize - 3), cellSize * i, 3, 0, 2 * Math.PI);
          } else if (i === (boardSize + 1) / 2) {
            ctx.arc(cellSize * 4, cellSize * i, 3, 0, 2 * Math.PI);
            ctx.arc(cellSize * (boardSize - 3), cellSize * i, 3, 0, 2 * Math.PI);
          } else {
            ctx.arc(cellSize * ((boardSize + 1) / 2), cellSize * i, 3, 0, 2 * Math.PI);
            ctx.arc(cellSize * 4, cellSize * i, 3, 0, 2 * Math.PI);
          }
          ctx.fill();
        }
      }
    }

    // 绘制坐标
    function drawAxis() {
      const xAxis = 'ABCDEFGHIJKLMNO'.split('');
      ctx.font = `${cellSize / 3.5}px serif`;
      ctx.fillStyle = 'black';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      for (let i = 0; i < boardSize; i++) {
        let m = (i + 1) * cellSize, n = (boardSize + .5) * cellSize, d = cellSize / 2
        ctx.fillText(xAxis[i], m, d);
        ctx.fillText(xAxis[i], m, n);
        ctx.fillText(boardSize - i, d, m);
        ctx.fillText(boardSize - i, n, m);
      }
    }

    // 绘制影子棋子
    function drawMarkPiece(ctx, x, y, size, color) {
      ctx.beginPath();
      ctx.arc(x * size + size, y * size + size, size / 2.5, 0, 2 * Math.PI);
      ctx.fillStyle = color;
      ctx.fill();
      // ctx.stroke();
    }

    // 绘制棋子
    function drawPiece(ctx, x, y, size, color) {
      ctx.drawImage(pieceImages[color], (x + .6) * size, (y + .6) * size, size / 1.25, size / 1.25);
    }

    // 绘制手数
    function drawStep(ctx, x, y, size, step, color) {
      ctx.font = `${size / 2}px serif`;
      ctx.fillStyle = color;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(step, (y + 1) * size, (x + 1) * size);
    }

    // 标记最后一手
    function drawLastPiece(ctx, x, y, size, color) {
      ctx.beginPath();
      ctx.arc(x * size + size, y * size + size, size / 10, 0, 2 * Math.PI);
      ctx.fillStyle = color;
      ctx.fill();
    }

    // 遍历所有行、列和斜线
    function traverseDiagonals(matrix, player, fn) {
      const m = matrix.length;
      const n = matrix[0].length;

      // 遍历所有行
      for (let i = 0; i < m; i++) {
        let diagonal = [];
        for (let j = 0; j < n; j++) {
          diagonal.push(matrix[i][j]);
        }
        if (fn(diagonal, player)) return player;
      }

      // 遍历所有列
      for (let i = 0; i < m; i++) {
        let diagonal = [];
        for (let j = 0; j < n; j++) {
          diagonal.push(matrix[j][i]);
        }
        if (fn(diagonal, player)) return player;
      }

      // 遍历右上角所有对角线包括从左上到右下对角线
      for (let i = 0; i < m; i++) { // d 是对角线的偏移量
        let diagonal = [];
        for (let j = 0; j < i + 1; j++) {
          diagonal.push(matrix[j][n + j - 1 - i]);
        }
        if (fn(diagonal, player)) return player;
      }

      // 遍历左下角所有对角线不包括从左上到右下对角线
      for (let i = 1; i < m; i++) {
        let diagonal = [];
        for (let j = i; j < n; j++) {
          diagonal.push(matrix[j][j - i]);
        }
        if (fn(diagonal, player)) return player;
      }

      // 遍历左上角所有对角线包括从右上到左下对角线
      for (let i = m - 1; i >= 0; i--) {
        let diagonal = [];
        for (let j = 0; j < n - i; j++) {
          diagonal.push(matrix[j][n - j - 1 - i]);
        }
        if (fn(diagonal, player)) return player;
      }

      // 遍历右下角所有对角线不包括从右上到左下对角线
      for (let i = 1; i < m; i++) {
        let diagonal = [];
        for (let j = i; j < n; j++) {
          diagonal.push(matrix[j][n - 1 - j + i]);
        }
        if (fn(diagonal, player)) return player;
      }
    }

    // 检查是赢棋方
    function checkLine(line, player) {
      for (let i = 0; i < 11; i++) {
        if (line[i]?.color === player && line[i + 1]?.color === player &&
          line[i + 2]?.color === player && line[i + 3]?.color === player &&
          line[i + 4]?.color === player) {
          return true;
        }
      }
    }

    // 显示获胜方
    function openDialog(winner) {
      document.getElementById('winner').innerText = winner === 'black' ? '黑方获胜' : '白方获胜';
      document.getElementById('dialog').className = 'dialog open';
    }

    // 开始游戏
    function start() {
      currentPlayer = { x: 0, y: 0, step: 0, color: 'black' };
      currentStep = 1; // 当前手数
      gameOver = false;
      gameBoard = Array(boardSize).fill().map(() => Array(boardSize).fill(null));
      lastHoverPoint = null;
      drawBoard();
      drawAxis();
    }

    // 重新开始
    function restart() {
      document.getElementById('dialog').className = 'dialog';
      clearCanvas(ctx);
      clearCanvas(nctx);
      start();
    }

    // 显示手数
    function showStep() {
      let color = '';

      clearCanvas(nctx);

      if (stepShow) {
        drawLastPiece(nctx, currentPlayer.x, currentPlayer.y, cellSize, 'red');
      } else {
        gameBoard.forEach((item, index) => {
          item.forEach((entry, idx) => {
            if (entry?.step) {
              drawStep(
                nctx,
                index,
                idx,
                cellSize,
                entry.step,
                entry.step === currentStep - 1 ? 'red' : entry.color === 'black' ? 'white' : 'black'
              );
            }
          })
        })
      }

      stepShow = !stepShow;
    }

    function clearCanvas(ctx) {
      ctx.clearRect(0, 0, max, max);
    }

    // 处理鼠标点击事件
    function handleMouseClick(event) {
      if (gameOver || event.target.nodeName.toLowerCase() !== 'canvas') return;

      const rect = canvas.getBoundingClientRect();
      const x = Math.floor((event.clientX - rect.left - cellSize / 2) / cellSize);
      const y = Math.floor((event.clientY - rect.top - cellSize / 2) / cellSize);
      let winner;

      if (x >= 0 && y >= 0 && x < boardSize && y < boardSize && gameBoard[y][x] === null) {
        if (currentPlayer.step > 0) {
          nctx.clearRect((currentPlayer.x + .5) * cellSize, (currentPlayer.y + .5) * cellSize, cellSize, cellSize);

          if (stepShow) {
            drawStep(nctx, currentPlayer.y, currentPlayer.x, cellSize, currentPlayer.step, currentPlayer.color);
          }
        }

        if (stepShow) {
          drawStep(nctx, y, x, cellSize, currentPlayer.step + 1, 'red');
        } else {
          drawLastPiece(nctx, x, y, cellSize, 'red');
        }

        currentPlayer = { x, y, color: currentPlayer.color, step: currentStep++ }
        gameBoard[y][x] = { color: currentPlayer.color, step: currentPlayer.step };
        audio.play();
        drawPiece(ctx, x, y, cellSize, currentPlayer.color === 'black' ? 'black' : 'white');

        // 检查是否获胜
        winner = traverseDiagonals(gameBoard, currentPlayer.color, function (line, player) {
          if (checkLine(line, player)) return player
        });

        if (winner) {
          gameOver = true;
          winAudio.play();
          openDialog(winner);
          return;
        }
        // 切换玩家
        currentPlayer.color = currentPlayer.color === 'black' ? 'white' : 'black';
      }
    }

    // 处理鼠标hover事件
    function handleMouseMove(event) {
      if (gameOver || event.target.nodeName.toLowerCase() !== 'canvas') {
        clearCanvas(mctx);
        return;
      }

      const rect = mark.getBoundingClientRect();
      const left = (event.clientX - rect.left - cellSize / 2) / cellSize
      const top = (event.clientY - rect.top - cellSize / 2) / cellSize
      const x = Math.floor((event.clientX - rect.left - cellSize / 2) / cellSize);
      const y = Math.floor((event.clientY - rect.top - cellSize / 2) / cellSize);

      if (x < 0 || y < 0 || x >= boardSize || y >= boardSize) {
        clearCanvas(mctx);
      }

      if (x >= 0 && y >= 0 && x < boardSize && y < boardSize && gameBoard[y][x] === null) {
        clearCanvas(mctx);
        drawMarkPiece(mctx, x, y, cellSize, currentPlayer.color === 'black' ? 'rgba(0, 0, 0, .3)' : 'rgba(255, 255, 255, .3)');
        lastHoverPoint = { x, y };
      }
    }

    document.addEventListener('click', handleMouseClick);
    document.addEventListener('mousemove', handleMouseMove);

    start();
  </script>
</body>

</html>